import java.util.ArrayList;
import java.util.List;

public class outOfMemory {
    /* Исследование раздела памяти Heap(куча) */
    public static void main(String[] args) {
        try1();
        try2();
        try3();
        shortOut();
    }
    public static void shortOut() {
    /* Как исчерпать память в Heap одной строкой*/
        long[] l=new long[Integer.MAX_VALUE];
    }
    public static void try1() {
        /* Цикл будет работать бесконечно, но при этом раздел памяти Heap исчерпан не будет,
        т.к. не создается ни одной локальной переменной и поэтому нет ссылок из Steak в Heap.
        Следовательно сколько бы мы не создавали объектов все они будут удалены Garbage collector*/
        while (true) {
            new Object();
        }
    }
    public static void try2() {
        /* Цикл будет работать бесконечно, но при этом раздел памяти Heap исчерпан не будет,
        Локальная переменная у нас есть и следовательно будет и ссылка из Steak в Heap.
        Но при каждом шаге цикла ссылка каждый раз будет перезаписываться на вновь созданный объект,
        а предыдущий созданный останется без ссылки. Следовательно сколько бы мы не создавали объектов
        все они будут удалены Garbage collector за исключением одного текущего */
        Object obj;
        while (true) {
            obj=new Object();
        }
    }
    public static void try3() {
        /* Цикл будет прерван исключением OutOfMemoryError, т.к. память будет исчерпана.
        Мы создаем динамический массив, значения которого будут хранится в Heap, а ссылки на эти значения
        в Steak. При каждом шаге цикла мы создаем объект и добавляем элемент массива(т.е. и новую ссылку тоже)
        Все ссылки живые, поэтому Garbage collector убирать их не имеет права */
        List<Object> list=new ArrayList<>();
        while(true) {
            list.add(new Object());
        }
    }
    public static void try4() {
        /* Цикл будет работать бесконечно, но при этом раздел памяти Heap исчерпан не будет,
        У нас есть переменная ref которой выделена память в Steak и в Heap хранится значение,
        т.е. у нас есть ссылка из Steak в Heap.
        Далее у нас создаются на каждом шаге цикла переменные a и b, у которых также есть ссылки Steak
        в Heap на их значения. Далее ссылки переприсваиваются и получается, что a ссылается на b и b на a.
        Но область видимости этих переменных определяется границами цикла(т.е. в Steak на каждом шаге
        цикла a и b создаются и стираются). В результате ссылок из Steak в Heap не существут.
        Получаем циклическую ссылку в Heap.
        Но у нас в цикле есть еще присвоение переменной ref ссылки на a. При этом на каждом шаге цикла
        происходит переброс ссылки с предыдущего значения a на текущее значение a.
        Т.е. мы в цикле генерируем бесконечное множество циклических ссыло a<->b, но все ссылки находятся
        в Heap. Из Steak ведет только одна ссылка - текущая на каждом конкретном шаге цикла.
        Получается что Garbage collector имеет право стереть все a<->b, т.к. на них нет ссылок снаружи
        Heap(за исключением одной текущей). */
        Object[] ref=new Object[1];
        while (true) {
            Object[] a=new Object[1];
            Object[] b=new Object[1];
            a[0]=b;
            b[0]=a;
            ref[0]=a;
        }
    }
}
