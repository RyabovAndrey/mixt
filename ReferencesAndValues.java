public class ReferencesAndValues {
    /* Иллюстрация различия хранения примитивных и ссылочных типов данных.
    Значения примитивных типов данных хранятся в стеке(Stack).
    Значения ссылочных типов данных хранятся в куче(Heap), а сами ссылки хранятся в
    стеке(Stack).
    Примитивные типы передаются по значению, ссылочные типы - по ссылке, а сами ссылки - по значению.
    */
    public static void main(String[] args) {
        /* При вызове метода в стеке определяется область памяти для хранения локальных переменных.
        Само тело метода хранится в Permanent Generation(специальная область памяти для хранения методов).
        Тело метода загружается один раз, но использоваться может столько раз, сколько раз вызван метод.
        Т.е. при многократном вызове метода память под тело метода не расходуется.
        Память многократно расходуется в стеке только под значения локальных переменных примитивных типов
        и под ссылки ссылочных типов(столько раз сколько вызывается метод). Освобождается по окончании работы метода.
        Память также расходуется в куче под хранение значений переменных ссылочных типов. Освобождается
        уборщиком мусора(Garbage collector) при отсутствии ссылок на значение.
        */

        /* Присваиваем x значение 0. Значение будет хранится в области стека,
        отведенного для main. */
        int x=0; // int - примитивный тип данных

        /* Присваиваем нулевому элементу arr значение 20. Значение (20) будет хранится
        в куче, а ссылка на значение 20 будет хранится в области стека отведенного для main */
        int[] arr={20}; // массив - ссылочный тип данных

        /* Присваиваем x значение 0. Значение будет хранится в области стека,
        отведенного для main. */
        String s="Старое значение"; // String - ссылочный тип данных

        /* вызываем f и аргументу x присваиваем значение x из main, т.е 0
        аргументу arr присваиваем ссылку  arr из main(передается именно ссылка, а не значение) */
        f(x,arr);

        /* После возвращения из метода f у нашего x из main значение все еще 0, т.к. x в f
        был стерт при закрытии метода.
        в arr у нас ссылка на значение(ссылка все та же, а вот значение этой ссылки мы поменяли из f
        и сейчас перейдя по той же самой ссылке мы получим значение {40} */
        System.out.println("x="+x+"   arr[0]="+arr[0]);

        /* вызываем g и аргументу x присваиваем значение x из main, т.е 0
        аргументу arr присваиваем ссылку  arr из main(передается именно ссылка, а не значение) */
        g(x,arr);

        /* После возвращения из метода g у нашего x из main значение все еще 0, т.к. x в g
        был стерт при закрытии метода.
        в arr у нас ссылка на значение(ни ссылка ни значение по ссылке не поменялись, т.к. в g мы содавали
        новую ссылку и новое значение) */
        System.out.println("x="+x+"   arr[0]="+arr[0]);


        // а вот со строкой такой фокус не проходит, хотя String - ссылочный тип данных, как и массив.
        h(x,s);
        System.out.println("x="+x+"   s="+s);
        /* При выполнении операции вычисляются последовательно слева на право. При этом перед запуском
         метода сначала вычесляются аргументы, поэтому сначала вычисляется метод l, а затем k.
         Результат работы метода l - расчитан второй аргумент для k и это ссылка на {77}
         Результат работы метода k - 42.
         Значению x присваиваем результат работы k, т.е. 42. arr[0] у нас по прежнему {40}, т.к.
         все манипуляции в l и k не затрагивали значение по ссылке {40}*/
        x=k(x,l(x,arr));
        System.out.println("x="+x+"   arr[0]="+arr[0]);
    }
    public static void f(int x,int[] arr) {
        /* Формируется область стека под f. В этой области для локальной переменной x присвоится значение 0,
        а в arr пропишется ссылка на значение {20} в куче(т.е. сейчас на значение {20} у нас две ссылки:
        первая - из arr в f, вторая - из arr в main ) */

        x+=30; // локальной переменной x присвоится значение 30

        arr[0]=40; //в куче перейдя по ссылке на {20} значение поменяется на {40}. При этом ссылка останется прежней

        /* По окончании работы метода f область памяти зарезервированная под f - особождается.
        При этом стираются все локальные переменные. Перестает существовать значение x и стирается ссылка на
        {40}(бывшее {20}), но при это ссылка из main остается).
        */
    }

    public static void g(int x,int[] arr) {
        /* Формируется область стека под g. В этой области для локальной переменной x присвоится значение 0,
        а в arr пропишется ссылка на значение {40} в куче(т.е. сейчас на значение {40} у нас две ссылки:
        первая - в arr из g, вторая - в arr из main ) */

        x+=50; // локальной переменной x присвоится значение 50

        /* с помощью new в куче создается новое значение в куче {60} и в стеке для arr в g передается
        ссылка на него. Т.е. в стеке для g ссылка на {40} из g стирается и на ее место пишется ссылка
        на {60}(при этом в стеке для main ссылка на {40} все еще существует). */
        arr=new int[]{60};

        /* По окончании работы метода g область памяти зарезервированная под g - особождается.
        При этом стираются все локальные переменные. Перестает существовать значение x и стирается ссылка на
        {60}. Кроме того стирается и само значение {60}, т.к. была стерта единственная ссылка на него.
        (Точнее значение будет уничтожено позже уборщиком мусора) */
    }

    public static void h(int x,String s) {
        x+=80;
        s="Новое значение"; // Казалось бы этим мы изменяем значение в куче, но этого не происходит.
    }


    public static int[] l(int x,int[] arr) {
        /*Формируется область стека под l. В этой области для локальной переменной x присвоится значение 0,
        а в arr пропишется ссылка на значение {40} в куче(т.е. сейчас на значение {40} у нас две ссылки:
        первая - в arr из l, вторая - в arr из main ) */

        x+=55; // локальной переменной x присвоится значение 55

        /* с помощью new в куче создается новое значение в куче {77} и в стеке для arr в l передается
        ссылка на него. Т.е. в стеке для l ссылка на {40} из g стирается и на ее место пишется ссылка
        на {77}(при этом в стеке для main ссылка на {40} все еще существует). */
        arr=new int[]{77};


        return arr; // Из l в main передается ссылка на {77}

        /*По окончании работы метода l область памяти зарезервированная под l - особождается.
        При этом стираются все локальные переменные. Перестает существовать значение x и стирается ссылка из l на
        {77}. Но само значение {77} не стирается в куче, т.к. ссылка на него осталась(передалась в main). */
    }

    public static int k(int x,int[] arr) {
        /*Формируется область стека под k. В этой области для локальной переменной x присвоится значение 0,
        а в arr пропишется ссылка на значение {77} в куче(т.е. сейчас в куче у нас две ссылки:
        первая - на {77} из k, вторая - на {40} из main ) */


        x+=10; // локальной переменной x присвоится значение 10

        arr[0]=75; //в куче перейдя по ссылке на {77} значение поменяется на {75}. При этом ссылка останется прежней

        return 42; // возвращаем 42

        /* По окончании работы метода k область памяти зарезервированная под k - особождается.
        При этом стираются все локальные переменные. Перестает существовать значение x и стирается ссылка на
        {77}. Кроме того стирается и само значение {77}, т.к. была стерта единственная ссылка на него.
        (Точнее значение будет уничтожено позже уборщиком мусора) */
    }
}
